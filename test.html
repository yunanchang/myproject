<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="./GASP/gsap/gsap.js"></script>
  <style>
    body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: "Inter", sans-serif;
}

#sketch {
  width: 100vw;
  height: 100vh;
  background: black;
}

.loading span {
  animation: blur 1.5s calc(var(--i) / 5 * 1s) alternate infinite;
}

@keyframes blur {
  to {
    filter: blur(5px);
  }
}

  </style>
</head>
<body>
  <div id="sketch"></div>
<div class="fixed z-5 top-0 left-0 loader-screen w-screen h-screen transition-all duration-300 bg-white">
  <div class="absolute hv-center">
    <div class="loading text-3xl tracking-widest whitespace-no-wrap">
      <span style="--i: 0">L</span>
      <span style="--i: 1">O</span>
      <span style="--i: 2">A</span>
      <span style="--i: 3">D</span>
      <span style="--i: 4">I</span>
      <span style="--i: 5">N</span>
      <span style="--i: 6">G</span>
    </div>
  </div>
</div>
<div class="hero-dom opacity-0">
  <div class="absolute hv-center">
    <div class="flex flex-col items-center space-y-2 whitespace-no-wrap">
      <div class="text-8xl text-white">ABSORB</div>
      <div class="text-xl" style="color: #8a8a8a;">A curve powered animation</div>
    </div>
  </div>
</div>
<script>
  import * as kokomi from "https://esm.sh/kokomi.js";
import * as THREE from "https://esm.sh/three";
import gsap from "https://esm.sh/gsap";

const vertexShader = /* glsl */ `
uniform float iTime;
uniform vec3 iResolution;
uniform vec4 iMouse;

varying vec2 vUv;

uniform vec3 uPosition;
uniform float uRotation;
uniform float uScale;

mat2 rotation2d(float angle){
    float s=sin(angle);
    float c=cos(angle);
    
    return mat2(
        c,-s,
        s,c
    );
}

vec2 rotate(vec2 v,float angle){
    return rotation2d(angle)*v;
}

void main(){
    vec3 p=position;
    p.xy=rotate(p.xy,uRotation);
    p.xyz*=uScale;
    p+=uPosition;
    gl_Position=projectionMatrix*modelViewMatrix*vec4(p,1.);
    
    vUv=uv;
}
`;

const fragmentShader = /* glsl */ `
uniform float iTime;
uniform vec3 iResolution;
uniform vec4 iMouse;

varying vec2 vUv;

uniform sampler2D iChannel0;
uniform float uOpacity;
uniform vec3 uTintColor;

void main(){
    vec2 uv=vUv;
    vec4 tex=texture(iChannel0,uv);
    vec3 col=tex.xyz*uTintColor;
    // col=uTintColor;
    gl_FragColor=vec4(col,uOpacity*.9);
}
`;

const fragmentShader2 = /* glsl */ `
uniform float iTime;
uniform vec2 iResolution;
uniform vec2 iMouse;

uniform sampler2D tDiffuse;

varying vec2 vUv;

uniform vec3 uBgColor;
uniform float uRGBShiftIntensity;
uniform float uGrainIntensity;
uniform float uVignetteIntensity;
uniform float uTransitionProgress;

highp float random(vec2 co)
{
    highp float a=12.9898;
    highp float b=78.233;
    highp float c=43758.5453;
    highp float dt=dot(co.xy,vec2(a,b));
    highp float sn=mod(dt,3.14);
    return fract(sin(sn)*c);
}

vec3 grain(vec2 uv,vec3 col,float amount){
    float noise=random(uv+iTime);
    col+=(noise-.5)*amount;
    return col;
}

vec4 RGBShift(sampler2D tex,vec2 uv,float amount){
    vec2 rUv=uv;
    vec2 gUv=uv;
    vec2 bUv=uv;
    float noise=random(uv+iTime)*.5+.5;
    vec2 offset=amount*vec2(cos(noise),sin(noise));
    rUv+=offset;
    gUv+=offset*.5;
    bUv+=offset*.25;
    vec4 rTex=texture(tex,rUv);
    vec4 gTex=texture(tex,gUv);
    vec4 bTex=texture(tex,bUv);
    vec4 col=vec4(rTex.r,gTex.g,bTex.b,gTex.a);
    return col;
}

vec3 vignette(vec2 uv,vec3 col,vec3 vigColor,float amount){
    vec2 p=uv;
    p-=.5;
    float d=length(p);
    float mask=smoothstep(.5,.3,d);
    mask=pow(mask,.6);
    float mixFactor=(1.-mask)*amount;
    col=mix(col,vigColor,mixFactor);
    return col;
}

float sdCircle(vec2 p,float r)
{
    return length(p)-r;
}

vec3 transition(vec2 uv,vec3 col,float progress){
    float ratio=iResolution.x/iResolution.y;
    
    // circle
    vec2 p=uv;
    p-=.5;
    p.x*=ratio;
    float d=sdCircle(p,progress*sqrt(2.2));
    float c=smoothstep(-.2,0.,d);
    col=mix(vec3(1.),texture(tDiffuse,uv).xyz,1.-c);
    return col;
}

void main(){
    vec2 uv=vUv;
    vec4 tex=RGBShift(tDiffuse,uv,uRGBShiftIntensity);
    vec3 col=tex.xyz;
    col=grain(uv,col,uGrainIntensity);
    col=vignette(uv,col,uBgColor,uVignetteIntensity);
    col=transition(uv,col,uTransitionProgress);
    gl_FragColor=vec4(col,1.);
}
`;

class ImageCurve extends kokomi.Component {
  constructor(base, config = {}) {
    super(base);

    const {
      curve,
      texture,
      material,
      offset = 0,
      rotationCurve,
      scaleCurve,
      opacityCurve
    } = config;

    this.curve = curve;
    this.texture = texture;
    this.material = material;
    this.offset = offset;
    this.rotationCurve = rotationCurve;
    this.scaleCurve = scaleCurve;
    this.opacityCurve = opacityCurve;

    this.progress = 0;
    this.position = new THREE.Vector3(0, 0, 0);
    this.rotation = new THREE.Euler();
    this.scale = new THREE.Vector3(1, 1, 1);
    this.opacity = new THREE.Vector3(1, 1, 1);
    this.speed = 1;

    const g = new THREE.Group();
    this.g = g;

    const width = this.texture.image.width * 0.005;
    const height = this.texture.image.height * 0.005;
    const geometry = new THREE.PlaneGeometry(width, height);

    const mesh = new THREE.Mesh(geometry, material);
    this.mesh = mesh;

    this.g.add(this.mesh);
  }
  addExisting() {
    this.container.add(this.g);
  }
  syncPos(u) {
    this.curve.getPointAt(u, this.position);
    this.material.uniforms.uPosition.value = this.position;
  }
  syncRotation(u) {
    this.rotationCurve.getPointAt(u, this.rotation);
    this.material.uniforms.uRotation.value = this.rotation.y;
  }
  syncScale(u) {
    this.scaleCurve.getPointAt(u, this.scale);
    this.material.uniforms.uScale.value = 1 - this.scale.y;
  }
  syncOpacity(u) {
    this.opacityCurve.getPointAt(u, this.opacity);
    this.material.uniforms.uOpacity.value = this.opacity.y;
  }
  moveForth() {
    const normalizedDelta = this.base.clock.deltaTime / 0.016;
    this.progress += 0.0018 * normalizedDelta * this.speed;
  }
  update() {
    this.moveForth();
    let i = this.progress + this.offset;
    i = i % 1;
    const i2 = Math.pow(i, 1.7);
    this.syncPos(i2);
    this.syncRotation(i);
    this.syncScale(i2);
    this.syncOpacity(i);

    this.base.uj.injectShadertoyUniforms(this.material.uniforms);
  }
}

class ImageSpiral extends kokomi.Component {
  constructor(base, config = {}) {
    super(base);

    const {
      curve,
      textures,
      material,
      rotationCurve,
      scaleCurve,
      opacityCurve
    } = config;

    this.speed = 1;

    const g = new THREE.Group();
    this.g = g;

    const imageCurves = textures.map((tex, i) => {
      const mat = material.clone();
      mat.uniforms.iChannel0.value = tex;
      const ic = new ImageCurve(this.base, {
        curve,
        texture: tex,
        material: mat,
        offset: i / textures.length,
        rotationCurve,
        scaleCurve,
        opacityCurve
      });
      return ic;
    });
    this.imageCurves = imageCurves;
  }
  addExisting() {
    this.imageCurves.forEach((ic) => {
      ic.addExisting();
      this.g.add(ic.g);
    });
    this.container.add(this.g);
  }
  update() {
    this.imageCurves.forEach((ic) => {
      ic.speed = this.speed;
    });
  }
}

class Sketch extends kokomi.Base {
  create() {
    window.experience = this;

    const config = {
      bgColor: "#0c0c0c"
    };

    const params = {
      speed: 1,
      transitionProgress: 0
    };

    this.renderer.setClearColor(new THREE.Color(config.bgColor), 1);

    this.camera.position.set(0, 0, 8);
    this.camera.fov = 45;
    this.camera.updateProjectionMatrix();

    // new kokomi.OrbitControls(this);

    const resourceList = [...Array(50).keys()].map((_, i) => ({
      name: `tex${i + 1}`,
      type: "texture",
      path: `https://picsum.photos/id/${i + 1}/320/400`
    }));
    const am = new kokomi.AssetManager(this, resourceList);

    am.on("ready", () => {
      document.querySelector(".loader-screen")?.classList.add("hollow");

      // https://threejs.org/examples/webgl_geometry_spline_editor
      const curve = new THREE.CatmullRomCurve3([
        new THREE.Vector3(-7, -1, -8),
        new THREE.Vector3(-6.8, -0.2, -7),
        new THREE.Vector3(-6.4, 0.3, -6),
        new THREE.Vector3(-5.9, 0.7, -5),
        new THREE.Vector3(-5.4, 1, -4),
        new THREE.Vector3(-4.8, 1.2, -3),
        new THREE.Vector3(-3.9, 1.3, -1.8),
        new THREE.Vector3(-2.8, 1, -1),
        new THREE.Vector3(-1.5, 0.6, 0),
        new THREE.Vector3(-1, 0.4, 0)
      ]);
      this.curve = curve;

      // a range for rotation
      const rotationCurve = new THREE.SplineCurve([
        new THREE.Vector2(0, THREE.MathUtils.degToRad(-5)),
        new THREE.Vector2(1, THREE.MathUtils.degToRad(45))
      ]);
      this.rotationCurve = rotationCurve;

      // https://easings.net/#easeInCirc
      const scaleCurve = new THREE.CubicBezierCurve(
        new THREE.Vector2(0, 0),
        new THREE.Vector2(0.55, 0),
        new THREE.Vector2(1, 0.45),
        new THREE.Vector2(1, 1)
      );
      this.scaleCurve = scaleCurve;

      // https://easings.net/#easeOutCirc
      const opacityCurve = new THREE.CubicBezierCurve(
        new THREE.Vector2(0, 0),
        new THREE.Vector2(0, 0.55),
        new THREE.Vector2(0.45, 1),
        new THREE.Vector2(1, 1)
      );
      this.opacityCurve = opacityCurve;

      const uj = new kokomi.UniformInjector(this);
      this.uj = uj;
      const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        transparent: true,
        uniforms: {
          ...uj.shadertoyUniforms,
          iChannel0: {
            value: null
          },
          uPosition: {
            value: new THREE.Vector3(0, 0, 0)
          },
          uRotation: {
            value: 0
          },
          uScale: {
            value: 1
          },
          uOpacity: {
            value: 1
          },
          uTintColor: {
            value: new THREE.Color("#a5a5a5")
          }
        }
      });

      const spiralCount = 5;
      const spiralImageCount = 10;
      const spirals = [...Array(spiralCount).keys()].map((_, i) => {
        const is = new ImageSpiral(this, {
          textures: Object.values(am.items).slice(
            i * spiralImageCount,
            (i + 1) * spiralImageCount
          ),
          material,
          curve,
          rotationCurve,
          scaleCurve,
          opacityCurve
        });
        is.addExisting();
        is.g.rotation.z = THREE.MathUtils.degToRad((360 / spiralCount) * i);
        return is;
      });
      this.spirals = spirals;

      const ce = new kokomi.CustomEffect(this, {
        fragmentShader: fragmentShader2,
        uniforms: {
          uBgColor: {
            value: new THREE.Color(config.bgColor)
          },
          uRGBShiftIntensity: {
            value: 0.0025
          },
          uGrainIntensity: {
            value: 0.025
          },
          uVignetteIntensity: {
            value: 1
          },
          uTransitionProgress: {
            value: 0
          }
        }
      });
      ce.addExisting();
      this.ce = ce;

      // tilt with inertia
      let offsetX = 0;
      let offsetY = 0;

      this.update(() => {
        const tiltIntensity = 0.025;
        const tiltLerpFactor = 0.05;

        const { x, y } = this.interactionManager.mouse;

        offsetX = THREE.MathUtils.lerp(offsetX, x, tiltLerpFactor);
        offsetY = THREE.MathUtils.lerp(offsetY, y, tiltLerpFactor);

        this.camera.rotation.x = tiltIntensity * offsetY;
        this.camera.rotation.y = -tiltIntensity * offsetX;
      });

      // params
      this.update(() => {
        this.spirals.forEach((spiral) => {
          spiral.speed = params.speed;
        });

        this.ce.customPass.material.uniforms.uTransitionProgress.value =
          params.transitionProgress;
      });

      const anime = () => {
        const t1 = gsap.timeline();
        t1.to(params, {
          transitionProgress: 1,
          duration: 1,
          ease: "power1.inOut"
        })
          .fromTo(
            params,
            {
              speed: 15
            },
            {
              speed: 1,
              duration: 2,
              ease: "power1.inOut"
            },
            "-=1"
          )
          .to(
            ".hero-dom",
            {
              opacity: 1
            },
            "-=1.5"
          );
      };

      anime();
    });
  }
}

const sketch = new Sketch("#sketch");
sketch.create();

</script>
</body>
</html>